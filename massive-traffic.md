> 미완 : 가상 면접 사례 책 읽어보기 

## 대규모 트래픽 대응
1. ngrinder 성능 테스트로 병목 지점 파악
   * cpu, memory 사용량 : 사용률이 낮은데 성능이 안나온 다면 thread 증설
   * database 사용량 : cpu 사용률이 낮으면 connection pool size 증설, 메모리 사용률이 높으면 쿼리 병목 지점 확인 후 튜닝
2. 조회 성능 향상을 위해 캐시 적용
    * 로컬 캐시 : 데이터가 적거나 정합성이 필요 없는 경우
    * 글로벌 캐시 : 데이터가 많거나 정합성이 필요한 경우
3. 특정 도메인에 요청이 몰린다면 특정 도메인을 별도 서버로 분리하고 해당 서버만 스케일 아웃
   * 트래픽이 많이 몰리는 write 작업에 대해서 완전한 실시간 성이 아닌 준 실시간성만 만족해도 된다면 kafka를 도입하여 이벤트로 처리
   * 특정 zone에서 몰리는 경우, pod의 zone 위치도 고려
   * MSA로 분리하면서는 특정 서버에서 문제가 발생하는 경우도 대응할 수 있도록 서킷브레이커로 차단 설정
4. CQRS로 read와 write 서버 별도 분리
5. read의 경우 더 빠르게 동작하기 위해 데이터를 비정규화하여 mongo, es에 별도 적재 후, read 서버에서는 해당 DB만 보도록 처리
6. write에서 mysql DB 테이블에 데이터가 너무 많이 쌓여 감당이 안되는 경우, 테이블 샤딩
   * 테이블 샤딩은 고려해야할 사항이 많으므로 가장 마지막에 사용.
   * 네이버에는 200억 건의 데이터를 가지고 있는 테이블도 있다.


## MSA로 변해가는 이유
수많은 트래픽을 받아야되는 서비스가 늘어나면서 서비스를 쪼개고 장애 전파를 막기 시작했다. 사실 서버 자체는 비교적 비용이 싸기 때문에 계속 늘려서 트래픽을 견딜수도 있다. 하지만 일정치를 넘게되면 한 개의 DB로 감당하지 못하는 순간이 온다.(더이상 스케일 업이 불가능) 그래서 여러 개의 DB를 써야되는 순간이 발생하고 이 이유가 가장 큰 MSA로 전환해야하는 이유 중 하나라고 생각한다.  


## kafka exactly once
프로듀서는 idempotence와 acks 옵션으로 멱등성 구성으로 가져가면 exactly once와 순서를 보장할 수 있다.  
kafka 브로커에서 replica 옵션으로 파티션을 복제해두도록 하여 특정 브로커 발생 시에도 동작할 수 있는 ha 구성이 되어있다.  

컨슈머 단에서는 offset 커밋에서 네트워크 문제로 제대로 전달되지 않아 동일한 데이터를 중복해서 처리하는 경우가 발생할 수 있다. 따라서 zero-payload 방식으로 id값만 받아서 메시지 처리 시 데이터를 조회해서 처리하는 방식으로 멱등성 있게 구성해야 한다.


## 보상 트랜잭션
saga 패턴이 있다고는 알고 있는데 사용해본적이 없다.


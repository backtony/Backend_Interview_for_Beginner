> 미완 : 가상 면접 사례 책 읽어보기 

## 대규모 트래픽 대응
1. ngrinder 성능 테스트로 병목 지점 파악
   * cpu, memory 사용량 : 사용률이 낮은데 성능이 안나온 다면 thread 증설
   * database 사용량 : cpu 사용률이 낮으면 connection pool size 증설, 메모리 사용률이 높으면 쿼리 병목 지점 확인 후 튜닝
2. 조회 성능 향상을 위해 캐시 적용
    * 로컬 캐시 : 데이터가 적거나 정합성이 필요 없는 경우
    * 글로벌 캐시 : 데이터가 많거나 정합성이 필요한 경우
3. 특정 도메인에 요청이 몰린다면 특정 도메인을 별도 서버로 분리하고 해당 서버만 스케일 아웃
   * 트래픽이 많이 몰리는 write 작업에 대해서 완전한 실시간 성이 아닌 준 실시간성만 만족해도 된다면 kafka를 도입하여 이벤트로 처리
   * 특정 zone에서 몰리는 경우, pod의 zone 위치도 고려
   * 특정 도메인의 특정 api에 트래픽이 극한으로 몰리는 경우, 해당 도메인의 다른 기능 요청들에 대해서 처리를 못하는 경우가 생기므로 이 경우에는 기능별 스레드풀을 관리해서 처리하도록 한다. (자원을 요청별로 배분)
   * MSA로 분리하면서는 특정 서버에서 문제가 발생하는 경우도 대응할 수 있도록 서킷브레이커로 차단 설정
4. CQRS로 read와 write 서버 별도 분리
5. read의 경우 더 빠르게 동작하기 위해 데이터를 비정규화하여 mongo, es에 별도 적재 후, read 서버에서는 해당 DB만 보도록 처리
6. write에서 mysql DB 테이블에 데이터가 너무 많이 쌓여 감당이 안되는 경우, 테이블 샤딩
   * 테이블 샤딩은 고려해야할 사항이 많으므로 가장 마지막에 사용.
   * 네이버에는 200억 건의 데이터를 가지고 있는 테이블도 있다.


## MSA로 변해가는 이유
수많은 트래픽을 받아야되는 서비스가 늘어나면서 서비스를 쪼개고 장애 전파를 막기 시작했다. 사실 서버 자체는 비교적 비용이 싸기 때문에 계속 늘려서 트래픽을 견딜수도 있다. 하지만 일정치를 넘게되면 한 개의 DB로 감당하지 못하는 순간이 온다.(더이상 스케일 업이 불가능) 그래서 여러 개의 DB를 써야되는 순간이 발생하고 이 이유가 가장 큰 MSA로 전환해야하는 이유 중 하나라고 생각한다.  


## kafka exactly once
> cf) kafka 브로커에서 replica 옵션으로 파티션을 복제해두도록 하여 특정 브로커 발생 시에도 동작할 수 있는 ha 구성이 되어있다.

* 프로듀서의 멱등성 보장(3가지 방법)
  * idempotence true와 acks all 옵션으로 순차 멱등성을 어느정도 보장할 수 있다.
  * [트랜잭션 아웃박스패턴](https://blog.gangnamunni.com/post/transactional-outbox/)으로 자체적으로 발행되지 않은 건들에 대해 다시 발행하는 구조를 만들 수도 있다.  
    * 비즈니스 트랜잭션 안에 별도의 메시지 테이블에 데이터를 저장해두고 스케줄러로 메시지를 발행하고 발행했음을 마킹하는 등 (At-Least Once Delivery)을 보장하고 수신하는 쪽에서는 중복으로 메시지를 받아도 멱등성 있게 처리할 수 있는 구조
  * 트랜잭션 프로듀서 + read_commited 컨슈머 사용
    * 프로듀서는 트랜잭션 레코드를 추가해서 보내고 트랜잭션이 완료된 것이 확인된 레코드만 컨슈머가 읽어가는 형태
* 컨슈머 중복 메시지 처리 전략 : 컨슈머 단에서는 offset 커밋에서 네트워크 문제로 제대로 전달되지 않아 동일한 데이터를 중복해서 처리하는 경우가 발생할 수 있다. 따라서 zero-payload 방식으로 id값만 받아서 메시지 처리 시 데이터를 조회해서 처리하는 방식으로 멱등성 있게 구성해야 한다.
  * 메시지 키를 이용한 upsert 방식
    * 메시지 키를 db상에서 unique한 값으로 잡고 로직을 처리하는 과정에서 없으면 insert, 있으면 update로 처리
  * DB 유니크 제약 조건을 사용하여 중복 처리 해결  

개인적으로는 idempotence true와 acks all 옵션을 사용하여(로직상 applicationEventListener를 사용하여 afterCommit으로 처리한다.) 멱등성 프로듀서를 만들고 컨슈머 중복 메시지 처리 전략을 활용해서 멱등성 있는 컨슈머를 만드는 편이다.

## 보상 트랜잭션
saga 패턴이 있다고는 알고 있는데 사용해본적이 없다.

